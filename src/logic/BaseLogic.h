/**
 * @file
 * @brief Asbtract base class for Template Logic classes.
 *
 */
#pragma once

#include "ArchetypeManager.h"
#include "AssetManager.h"
#include "containers.h"
#include "themes_generated.h"
#include <SFML/Graphics/RenderTexture.hpp>
namespace steamrot {
using EntityIndicies = std::vector<size_t>;

/////////////////////////////////////////////////
/// @class LogicData
/// @brief General container for all logic data, such as other structs e.t.c
///
/////////////////////////////////////////////////
struct LogicData {

  /////////////////////////////////////////////////
  /// @brief Data copied over from any UI Elements
  /////////////////////////////////////////////////
  UIElementDataPackage ui_data_package;
};
/**
* @class LogicContext
 * @brief Provides all the specific Scene data required for logic processing.

 */
struct LogicContext {
  /**
   * @brief Struct memmber that contains a reference to the EntityMemoryPool for
   * this Scene.
   */
  components::containers::EntityMemoryPool &scene_entities;

  /**
   * @brief Struct member that contains a reference to the archetypes in the
   * Scene.
   */
  std::unordered_map<ArchetypeID, Archetype> &archetypes;

  /**
   * @brief Struct member that contains a reference to Scenes RenderTexture.
   */
  sf::RenderTexture &scene_texture;

  /////////////////////////////////////////////////
  /// @brief Reference to the game window.
  /////////////////////////////////////////////////
  sf::RenderWindow &game_window;

  /**
   * @brief Stuct member that contains UI thematic configuration.
   */
  const themes::UIObjects *ui_config{nullptr};

  /////////////////////////////////////////////////
  /// @brief Reference to the AssetManager for the game.
  /////////////////////////////////////////////////
  const AssetManager &asset_manager;

  /////////////////////////////////////////////////
  /// @brief user input events generated by the EventHandler
  /////////////////////////////////////////////////
  const EventBitset &user_events;
};

/**
 * @class BaseLogic
 * @brief Allows for polymorphic behaviour of template logic classes.
 *
 */
class BaseLogic {
protected:
  /**
   * @brief Collates all logic for the derived logic classes.
   *
   * @param entities Data structure containing all component data.
   * @param entity_indicies Entity mask for required entities.
   */
  virtual void ProcessLogic() = 0;

  /**
   * @brief How often the logic should be updated.
   */
  size_t m_update_frequency{1};

  /**
   * @brief Current cycle count for the logic. increased by RunLogic()
   */
  size_t m_cycle_count{1};

  /**
   * @brief Member variable that contains the context of the scene the logic
   * resides in.
   */
  LogicContext m_logic_context;

  ActionNames m_logic_action{0};

  /////////////////////////////////////////////////
  /// @brief Updated by Logic functions, will then be scraped by the Scene
  /////////////////////////////////////////////////
  LogicData m_logic_data;

public:
  /**
   * @brief Default constructor
   */
  BaseLogic(const LogicContext logic_context);

  /**
   * @brief Default destructor
   */
  virtual ~BaseLogic() = default;
  /**
   * @brief Guard function that to only update on the required frequency.
   *
   * @param entities Data structure containing all component data.
   * @param entity_indicies Entity mask for required entities.
   */
  void RunLogic();

  /////////////////////////////////////////////////
  /// @brief Return the Logic level action bit flag
  ///
  /// @return [TODO:return]
  /////////////////////////////////////////////////
  const ActionNames &GetLogicAction();

  const LogicData &GetLogicData() const;

  /////////////////////////////////////////////////
  /// @brief Reset the Logic level action to 0 value
  /////////////////////////////////////////////////
  void ResetLogicAction();
};
} // namespace steamrot
