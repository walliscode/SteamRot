////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////

#include "GameEngine.h"
#include "EventHandler.h"
#include "log_handler.h"
#include "uuid.h"

#include <SFML/Graphics.hpp>
#include <cstddef>

#include <iostream>
#include <magic_enum/magic_enum.hpp>
#include <magic_enum/magic_enum_iostream.hpp>
#include <memory>
#include <stdexcept>
#include <utility>

using namespace magic_enum::bitwise_operators;

namespace steamrot {

///////////////////////////////////////////////////////////
GameEngine::GameEngine()
    : m_window({sf::VideoMode(steamrot::kWindowSize), "SteamRot"}),
      m_data_manager(), m_event_handler(), m_asset_manager(),
      m_display_manager(m_window) {

  // create the GameContext object and pass by value so that it does not have to
  // stay alive
  GameContext game_context{m_window,         m_event_handler.GetEvents(),
                           m_mouse_position, m_loop_number,
                           m_asset_manager,  m_data_manager};

  // initialise all objects that need the GameContext
  m_scene_manager = std::make_unique<SceneManager>(game_context);

  std::cout << "GameEngine constructor called" << std::endl;
  log_handler::ProcessLog(spdlog::level::level_enum::info,
                          log_handler::LogCode::kNoCode,
                          "GameEngine constructor called");
}

////////////////////////////////////////////////////////////
void GameEngine::RunGame(size_t numLoops, bool use_test_window) {

  // set up resources for the game engine
  StartUp();

  // Start the game loop
  RunGameLoop();

  // Shut down the game engine
  ShutDown();
};

/////////////////////////////////////////////////
void GameEngine::StartUp() {

  // Start Title Scene
  ShowTitleScene();
}

void GameEngine::RunGameLoop() {

  // Run the program as long as the window is open
  while (m_window.isOpen()) {

    // handle loop number increase at beginning of loop
    m_loop_number++;

    // Handle events and return map of user events
    m_event_handler.HandleEvents(m_window);

    // Handle actions
    UpdateActions();

    // Handle all system updates
    UpdateSystems();

    // Pass render textures to the display manager
    PassRenderPackage();

    // statement to test whether to break the loop, must be called at end
    // if (numLoops > 0 && m_loop_number >= numLoops) {
    //   // export data to json, first variable is the directory name, second
    //   is
    //   // the file name
    //   ExportSimulationData("test");
    //   break;
    // };
  }
}

/////////////////////////////////////////////////
void GameEngine::UpdateActions() {
  // run action ssystems all the way down to Logic
  m_scene_manager->UpdateActions();
  // Process any actions that have been generated by the SceneManager
  GameEngine::ProcessActions();
}
////////////////////////////////////////////////////////////
void GameEngine::UpdateSystems() {

  // call the update function of the scene manager
  m_scene_manager->UpdateScenes();
}

////////////////////////////////////////////////////////////
void GameEngine::PassRenderPackage() {

  // textures package should only live for the duration of the render call so
  // called by value
  TexturesPackage textures_package = m_scene_manager->ProvideTexturesPackage();
  m_display_manager.Render(textures_package);
};

////////////////////////////////////////////////////////////
size_t GameEngine::getLoopNumber() { return m_loop_number; }

/////////////////////////////////////////////////
sf::RenderWindow &GameEngine::GetWindow() { return m_window; }

////////////////////////////////////////////////////////////
void GameEngine::RunSimulation(int loops) {
  // prevent undefined behaviour of simulation loop
  if (loops <= 0) {
    throw std::invalid_argument("The number of loops must be greater than 0");
  } else {
    GameEngine::RunGame(loops);
  }
}

/////////////////////////////////////////////////
const std::pair<ActionNames, SceneManagerDataPackage>
GameEngine::ScrapeSceneManagerForActions() {
  // get the actions and data from the scene manager
  return std::make_pair(m_scene_manager->GetSceneManagerAction(),
                        m_scene_manager->GetSceneManagerDataPackage());
}

/////////////////////////////////////////////////
void GameEngine::ProcessActions() {

  // scrape the scene manager for actions and data
  const std::pair<ActionNames, SceneManagerDataPackage> action_and_data =
      ScrapeSceneManagerForActions();

  // get the action name and data package
  ActionNames action_name = action_and_data.first;
  SceneManagerDataPackage scene_data_package = action_and_data.second;

  // process the action
  switch (action_name) {

  case (ActionNames::ActionNames_ACTION_CHANGE_SCENE): {
    std::cout << "Processing Scene Change at GameEngine level" << std::endl;
    // This deals with the GameEngine's functions for Title and Crafting scenes.
    // this approach probably needs to be redone

    if (scene_data_package.new_scene_type) {
      if (scene_data_package.new_scene_type == SceneType::title) {

        // Show the title scene
        std::cout << "Title scene type detected in GameEngine" << std::endl;
        ShowTitleScene();

      } else if (scene_data_package.new_scene_type == SceneType::crafting) {
        // Show the crafting scene
        std::cout << "Crafting scene type detected in GameEngine" << std::endl;
        ShowCraftingScene();
      }
    }
  }

  default:
    // no action, do nothing
    break;
  }
}
////////////////////////////////////////////////////////////
void GameEngine::ShowTitleScene() {
  std::cout << "Loading title scene..." << std::endl;
  // Load the title scene in the scene manager and get unique id
  uuids::uuid title_scene_id = m_scene_manager->LoadTitleScene();
  std::cout << "Title scene loaded with ID: " << title_scene_id << std::endl;
  // pass the id to the display manager
  m_display_manager.LoadTitleSceneTiles(title_scene_id);
  std::cout << "Title scene tiles loaded" << std::endl;
}
/////////////////////////////////////////////////
void GameEngine::ShowCraftingScene() {
  std::cout << "Loading crafting scene..." << std::endl;
  // Load the crafting scene in the scene manager and get unique id
  uuids::uuid crafting_scene_id = m_scene_manager->LoadCraftingScene();
  std::cout << "Crafting scene loaded with ID: " << crafting_scene_id
            << std::endl;
  // pass the id to the display manager
  m_display_manager.LoadCraftingSceneTiles(crafting_scene_id);
  std::cout << "Crafting scene tiles loaded" << std::endl;
}

////////////////////////////////////////////////////////////
void GameEngine::ShutDown() {}

} // namespace steamrot
