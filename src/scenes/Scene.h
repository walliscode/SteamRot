/////////////////////////////////////////////////
/// @file
/// @brief Declaration of the abstract Scene class.
/////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// Preprocessor directives
////////////////////////////////////////////////////////////
#pragma once

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "ActionManager.h"
#include "EntityManager.h"
#include "GameContext.h"
#include "Logic.h"
#include "LogicFactory.h"
#include "global_constants.h"
#include "scene_types_generated.h"
#include <SFML/Graphics.hpp>
#include <memory>
#include <unordered_map>
#include <unordered_set>

#include <uuid.h>
typedef std::vector<std::shared_ptr<sf::Drawable>> SceneDrawables;

namespace steamrot {
/////////////////////////////////////////////////
/// @class SceneInfo
/// @brief Captures essential information about a Scene.
///
/////////////////////////////////////////////////
struct SceneInfo {
  uuids::uuid id;
  SceneType type;
};
/////////////////////////////////////////////////
/// @class Scene
/// @brief Abstract base class for all Scenes in the game.
///
/////////////////////////////////////////////////
class Scene {
  friend class SceneFactory;

protected:
  /////////////////////////////////////////////////
  /// @brief Identifying information about the Scene.
  /////////////////////////////////////////////////
  const SceneInfo m_scene_info;

  ////////////////////////////////////////////////////////////
  // Member: Entity Manager instance
  ////////////////////////////////////////////////////////////
  EntityManager m_entity_manager;

  ////////////////////////////////////////////////////////////
  // Member: Action Manager instance
  ////////////////////////////////////////////////////////////
  ActionManager m_action_manager;

  /////////////////////////////////////////////////
  /// @brief GameContext object passed down from the GameEngine.
  /////////////////////////////////////////////////
  const GameContext &m_game_context;

  /////////////////////////////////////////////////
  /// @brief Map of all logic objects needed by the Scene.
  /////////////////////////////////////////////////
  std::unordered_map<LogicType, std::vector<std::unique_ptr<Logic>>>
      m_logic_map;

  /////////////////////////////////////////////////
  /// @brief RenderTexture for the Scene instance.
  /////////////////////////////////////////////////
  sf::RenderTexture m_render_texture{kWindowSize};

  /////////////////////////////////////////////////
  /// @brief Is the Scene active? Should update logic and render texture
  /////////////////////////////////////////////////
  bool m_active = true;

  /////////////////////////////////////////////////
  /// @brief contains all event types that the Scene is interested in
  /////////////////////////////////////////////////
  std::unordered_set<EventType> m_scene_event_types;

  /////////////////////////////////////////////////
  /// @brief Constructor for Scene class.
  ///
  /// @param id Generated UUID for the Scene.
  /// @param game_context GameContext object passed down from the GameEngine.
  /////////////////////////////////////////////////
  Scene(const SceneType scene_type, const uuids::uuid &id,
        const GameContext &game_context);

public:
  /////////////////////////////////////////////////
  /// @brief Destructor for Scene class.
  /////////////////////////////////////////////////
  virtual ~Scene() = default;

  /////////////////////////////////////////////////
  /// @brief wrapper function for any Scene configuration that needs to be done
  ///
  /// @param data_type Which data type to use for configuration.
  /////////////////////////////////////////////////
  std::expected<std::monostate, FailInfo>
  ConfigureFromDefault(const DataType &data_type = DataType::Flatbuffers);

  ////////////////////////////////////////////////////////////
  /// \brief function container for all movement related logic
  ///
  ////////////////////////////////////////////////////////////
  virtual void sMovement() = 0;

  /////////////////////////////////////////////////
  /// @brief Function container for all collision related logic.
  /////////////////////////////////////////////////
  virtual void sCollision() = 0;

  /////////////////////////////////////////////////
  /// @brief Virtual container function for running all action related logic.
  /////////////////////////////////////////////////
  virtual void sAction() = 0;

  /////////////////////////////////////////////////
  /// @brief Virtual container function for running all rendering related logic.
  /////////////////////////////////////////////////
  virtual void sRender() = 0;

  /////////////////////////////////////////////////
  /// @brief Returns a reference to the RenderTexture of the Scene.
  /////////////////////////////////////////////////
  sf::RenderTexture &GetRenderTexture();

  /////////////////////////////////////////////////
  /// @brief Returns a const reference to the LogicMap of the Scene.
  ///
  /// @return The LogicMap of the Scene.
  /////////////////////////////////////////////////
  const LogicCollection &GetLogicMap() const;

  /////////////////////////////////////////////////
  /// @brief Sets LogicMap for the scene (only if the map is empty)
  ///
  /// @param logic_map Logic map to set for the scene, passed by value and
  /// moved.
  /////////////////////////////////////////////////
  void
  SetLogicMap(std::unordered_map<LogicType, std::vector<std::unique_ptr<Logic>>>
                  logic_map);
  /////////////////////////////////////////////////
  /// @brief Returns the active state of the Scene.
  ///
  /// @return Boolean indicating if the Scene is active.
  /////////////////////////////////////////////////
  bool GetActive() const;

  ////////////////////////////////////////////////////////////
  /// \brief change the active state of the Scene
  ///
  ////////////////////////////////////////////////////////////
  void SetActive(bool active);

  /////////////////////////////////////////////////
  /// @brief Returns the SceneInfo of the Scene.
  /////////////////////////////////////////////////
  const SceneInfo &GetSceneInfo() const;

  /////////////////////////////////////////////////
  /// @brief Create and return a LogicContext for the Scene.
  ///
  /// @return a Scene specific LogicContext object
  /////////////////////////////////////////////////
  LogicContext GetLogicContext();

#ifdef DEBUG
  const EntityMemoryPool &GetEntityMemoryPool() const;

  const std::unordered_map<ArchetypeID, Archetype> &GetArchetypes() const;
#endif
};

} // namespace steamrot
