////////////////////////////////////////////////////////////
// preprocessor directives
////////////////////////////////////////////////////////////
#pragma once

////////////////////////////////////////////////////////////
// headers
////////////////////////////////////////////////////////////
#include "CMeta.h"
#include "CUserInterface.h"
#include <magic_enum/magic_enum.hpp>

namespace steamrot {
namespace components {

namespace containers {

////////////////////////////////////////////////////////////
// |brief: template helper struct
////////////////////////////////////////////////////////////
template <typename... Components> struct ComponentContainer;

////////////////////////////////////////////////////////////
// |brief: template specialistion for ComponentContainer. Tuples
////////////////////////////////////////////////////////////]b
template <typename... Components>
struct ComponentContainer<std::tuple<Components...>> {

  using ComponentVectorTuple = std::tuple<std::vector<Components>...>;
};
////////////////////////////////////////////////////////////
// |brief: ComponentRegister is a tuple of all the components for the game
//  "One source of truth"
////////////////////////////////////////////////////////////
typedef std::tuple<CMeta, CUserInterface> ComponentRegister;

////////////////////////////////////////////////////////////
// |brief: size of the component register
////////////////////////////////////////////////////////////
constexpr size_t kComponentRegisterSize =
    std::tuple_size<ComponentRegister>::value;

////////////////////////////////////////////////////////////
// |brief: typedef for EntityMemoryPool
////////////////////////////////////////////////////////////
using EntityMemoryPool =
    ComponentContainer<ComponentRegister>::ComponentVectorTuple;

////////////////////////////////////////////////////////////
// |brief: template helper for type indexing
////////////////////////////////////////////////////////////
template <typename T, typename... Ts> struct IndexOf;

////////////////////////////////////////////////////////////
// |brief: template specialisation for tuples for base case recursion
////////////////////////////////////////////////////////////
template <typename T, typename... Ts> struct IndexOf<T, std::tuple<T, Ts...>> {
  // base case where T is the first type in the tuple
  static constexpr size_t value = 0;
};
////////////////////////////////////////////////////////////
// |brief: template specialisation for tuples for recursive case
////////////////////////////////////////////////////////////
template <typename T, typename U, typename... Ts>
struct IndexOf<T, std::tuple<U, Ts...>> {
  // recursive case where T is not the first type in the tuple
  static constexpr size_t value = 1 + IndexOf<T, std::tuple<Ts...>>::value;
};

////////////////////////////////////////////////////////////
// |brief: helper type alias for getting the index of a type in a tuple
////////////////////////////////////////////////////////////
template <typename T, typename Tuple>
constexpr size_t TupleTypeIndex = IndexOf<T, Tuple>::value;

}; // namespace containers
}; // namespace components
}; // namespace steamrot
