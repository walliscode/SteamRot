// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_STEAMROT_H_
#define FLATBUFFERS_GENERATED_EVENTS_STEAMROT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "user_input_generated.h"

namespace steamrot {

enum EventType : uint64_t {
  EventType_EVENT_NONE = 1ULL,
  EventType_EVENT_TEST = 2ULL,
  EventType_EVENT_USER_INPUT = 4ULL,
  EventType_EVENT_CHANGE_SCENE = 8ULL,
  EventType_EVENT_QUIT_GAME = 16ULL,
  EventType_EVENT_TOGGLE_DROPDOWN = 32ULL,
  EventType_NONE = 0,
  EventType_ANY = 63ULL
};

inline const EventType (&EnumValuesEventType())[6] {
  static const EventType values[] = {
    EventType_EVENT_NONE,
    EventType_EVENT_TEST,
    EventType_EVENT_USER_INPUT,
    EventType_EVENT_CHANGE_SCENE,
    EventType_EVENT_QUIT_GAME,
    EventType_EVENT_TOGGLE_DROPDOWN
  };
  return values;
}

inline const char *EnumNameEventType(EventType e) {
  switch (e) {
    case EventType_EVENT_NONE: return "EVENT_NONE";
    case EventType_EVENT_TEST: return "EVENT_TEST";
    case EventType_EVENT_USER_INPUT: return "EVENT_USER_INPUT";
    case EventType_EVENT_CHANGE_SCENE: return "EVENT_CHANGE_SCENE";
    case EventType_EVENT_QUIT_GAME: return "EVENT_QUIT_GAME";
    case EventType_EVENT_TOGGLE_DROPDOWN: return "EVENT_TOGGLE_DROPDOWN";
    default: return "";
  }
}

enum EventDataData : uint8_t {
  EventDataData_NONE = 0,
  EventDataData_UserInputBitsetData = 1,
  EventDataData_MIN = EventDataData_NONE,
  EventDataData_MAX = EventDataData_UserInputBitsetData
};

inline const EventDataData (&EnumValuesEventDataData())[2] {
  static const EventDataData values[] = {
    EventDataData_NONE,
    EventDataData_UserInputBitsetData
  };
  return values;
}

inline const char * const *EnumNamesEventDataData() {
  static const char * const names[3] = {
    "NONE",
    "UserInputBitsetData",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventDataData(EventDataData e) {
  if (::flatbuffers::IsOutRange(e, EventDataData_NONE, EventDataData_UserInputBitsetData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEventDataData()[index];
}

template<typename T> struct EventDataDataTraits {
  static const EventDataData enum_value = EventDataData_NONE;
};

template<> struct EventDataDataTraits<steamrot::UserInputBitsetData> {
  static const EventDataData enum_value = EventDataData_UserInputBitsetData;
};

bool VerifyEventDataData(::flatbuffers::Verifier &verifier, const void *obj, EventDataData type);
bool VerifyEventDataDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

inline bool VerifyEventDataData(::flatbuffers::Verifier &verifier, const void *obj, EventDataData type) {
  switch (type) {
    case EventDataData_NONE: {
      return true;
    }
    case EventDataData_UserInputBitsetData: {
      auto ptr = reinterpret_cast<const steamrot::UserInputBitsetData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventDataDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEventDataData(
        verifier,  values->Get(i), types->GetEnum<EventDataData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace steamrot

#endif  // FLATBUFFERS_GENERATED_EVENTS_STEAMROT_H_
