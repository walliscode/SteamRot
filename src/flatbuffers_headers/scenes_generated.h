// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_
#define FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "assets_generated.h"
#include "entities_generated.h"
#include "logics_generated.h"

namespace steamrot {

struct SceneData;
struct SceneDataBuilder;

struct SceneData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SceneDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY_COLLECTION = 4,
    VT_LOGIC_COLLECTION = 6,
    VT_UI_THEME = 8,
    VT_ASSETS = 10
  };
  const steamrot::EntityCollection *entity_collection() const {
    return GetPointer<const steamrot::EntityCollection *>(VT_ENTITY_COLLECTION);
  }
  const steamrot::LogicCollection *logic_collection() const {
    return GetPointer<const steamrot::LogicCollection *>(VT_LOGIC_COLLECTION);
  }
  const ::flatbuffers::String *ui_theme() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UI_THEME);
  }
  const steamrot::AssetCollection *assets() const {
    return GetPointer<const steamrot::AssetCollection *>(VT_ASSETS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY_COLLECTION) &&
           verifier.VerifyTable(entity_collection()) &&
           VerifyOffset(verifier, VT_LOGIC_COLLECTION) &&
           verifier.VerifyTable(logic_collection()) &&
           VerifyOffsetRequired(verifier, VT_UI_THEME) &&
           verifier.VerifyString(ui_theme()) &&
           VerifyOffset(verifier, VT_ASSETS) &&
           verifier.VerifyTable(assets()) &&
           verifier.EndTable();
  }
};

struct SceneDataBuilder {
  typedef SceneData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_entity_collection(::flatbuffers::Offset<steamrot::EntityCollection> entity_collection) {
    fbb_.AddOffset(SceneData::VT_ENTITY_COLLECTION, entity_collection);
  }
  void add_logic_collection(::flatbuffers::Offset<steamrot::LogicCollection> logic_collection) {
    fbb_.AddOffset(SceneData::VT_LOGIC_COLLECTION, logic_collection);
  }
  void add_ui_theme(::flatbuffers::Offset<::flatbuffers::String> ui_theme) {
    fbb_.AddOffset(SceneData::VT_UI_THEME, ui_theme);
  }
  void add_assets(::flatbuffers::Offset<steamrot::AssetCollection> assets) {
    fbb_.AddOffset(SceneData::VT_ASSETS, assets);
  }
  explicit SceneDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SceneData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SceneData>(end);
    fbb_.Required(o, SceneData::VT_UI_THEME);
    return o;
  }
};

inline ::flatbuffers::Offset<SceneData> CreateSceneData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<steamrot::EntityCollection> entity_collection = 0,
    ::flatbuffers::Offset<steamrot::LogicCollection> logic_collection = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ui_theme = 0,
    ::flatbuffers::Offset<steamrot::AssetCollection> assets = 0) {
  SceneDataBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_ui_theme(ui_theme);
  builder_.add_logic_collection(logic_collection);
  builder_.add_entity_collection(entity_collection);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SceneData> CreateSceneDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<steamrot::EntityCollection> entity_collection = 0,
    ::flatbuffers::Offset<steamrot::LogicCollection> logic_collection = 0,
    const char *ui_theme = nullptr,
    ::flatbuffers::Offset<steamrot::AssetCollection> assets = 0) {
  auto ui_theme__ = ui_theme ? _fbb.CreateString(ui_theme) : 0;
  return steamrot::CreateSceneData(
      _fbb,
      entity_collection,
      logic_collection,
      ui_theme__,
      assets);
}

inline const steamrot::SceneData *GetSceneData(const void *buf) {
  return ::flatbuffers::GetRoot<steamrot::SceneData>(buf);
}

inline const steamrot::SceneData *GetSizePrefixedSceneData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<steamrot::SceneData>(buf);
}

inline bool VerifySceneDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<steamrot::SceneData>(nullptr);
}

inline bool VerifySizePrefixedSceneDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<steamrot::SceneData>(nullptr);
}

inline void FinishSceneDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<steamrot::SceneData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<steamrot::SceneData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace steamrot

#endif  // FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_
