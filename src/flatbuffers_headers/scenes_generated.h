// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_
#define FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "actions_generated.h"
#include "entities_generated.h"
#include "logics_generated.h"

namespace steamrot {

struct SceneData;
struct SceneDataBuilder;

struct SceneData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SceneDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIONS = 4,
    VT_ENTITIES = 6,
    VT_LOGICS = 8
  };
  const steamrot::ActionsData *actions() const {
    return GetPointer<const steamrot::ActionsData *>(VT_ACTIONS);
  }
  const steamrot::EntitiesData *entities() const {
    return GetPointer<const steamrot::EntitiesData *>(VT_ENTITIES);
  }
  const steamrot::LogicData *logics() const {
    return GetPointer<const steamrot::LogicData *>(VT_LOGICS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.VerifyTable(actions()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyTable(entities()) &&
           VerifyOffset(verifier, VT_LOGICS) &&
           verifier.VerifyTable(logics()) &&
           verifier.EndTable();
  }
};

struct SceneDataBuilder {
  typedef SceneData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actions(::flatbuffers::Offset<steamrot::ActionsData> actions) {
    fbb_.AddOffset(SceneData::VT_ACTIONS, actions);
  }
  void add_entities(::flatbuffers::Offset<steamrot::EntitiesData> entities) {
    fbb_.AddOffset(SceneData::VT_ENTITIES, entities);
  }
  void add_logics(::flatbuffers::Offset<steamrot::LogicData> logics) {
    fbb_.AddOffset(SceneData::VT_LOGICS, logics);
  }
  explicit SceneDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SceneData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SceneData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SceneData> CreateSceneData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<steamrot::ActionsData> actions = 0,
    ::flatbuffers::Offset<steamrot::EntitiesData> entities = 0,
    ::flatbuffers::Offset<steamrot::LogicData> logics = 0) {
  SceneDataBuilder builder_(_fbb);
  builder_.add_logics(logics);
  builder_.add_entities(entities);
  builder_.add_actions(actions);
  return builder_.Finish();
}

inline const steamrot::SceneData *GetSceneData(const void *buf) {
  return ::flatbuffers::GetRoot<steamrot::SceneData>(buf);
}

inline const steamrot::SceneData *GetSizePrefixedSceneData(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<steamrot::SceneData>(buf);
}

inline bool VerifySceneDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<steamrot::SceneData>(nullptr);
}

inline bool VerifySizePrefixedSceneDataBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<steamrot::SceneData>(nullptr);
}

inline void FinishSceneDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<steamrot::SceneData> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneDataBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<steamrot::SceneData> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace steamrot

#endif  // FLATBUFFERS_GENERATED_SCENES_STEAMROT_H_
